{"ast":null,"code":"import _regeneratorRuntime from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { getProvider } from \"../../\";\nimport { validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\n\nvar StateFactory = /*#__PURE__*/function () {\n  function StateFactory() {\n    _classCallCheck(this, StateFactory);\n  }\n\n  _createClass(StateFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      if (idl.state === undefined) {\n        return undefined;\n      }\n\n      return new StateClient(idl, programId, provider, coder);\n    }\n  }]);\n\n  return StateFactory;\n}();\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\n\n\nexport { StateFactory as default };\nexport var StateClient = /*#__PURE__*/function () {\n  function StateClient(idl, programId) {\n    var provider = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getProvider();\n    var coder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Coder(idl);\n\n    _classCallCheck(this, StateClient);\n\n    this.provider = provider;\n    this.coder = coder;\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._sub = null; // Build namespaces.\n\n    var _ref = function () {\n      var _a;\n\n      var instruction = {};\n      var transaction = {};\n      var rpc = {};\n      (_a = idl.state) === null || _a === void 0 ? void 0 : _a.methods.forEach(function (m) {\n        // Build instruction method.\n        var ixItem = InstructionNamespaceFactory.build(m, function (ixName, ix) {\n          return coder.instruction.encodeState(ixName, ix);\n        }, programId);\n\n        ixItem[\"accounts\"] = function (accounts) {\n          var keys = stateInstructionKeys(programId, provider, m, accounts);\n          return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\n        }; // Build transaction method.\n\n\n        // Build transaction method.\n        var txItem = TransactionNamespaceFactory.build(m, ixItem); // Build RPC method.\n\n        // Build RPC method.\n        var rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider); // Attach them all to their respective namespaces.\n\n        // Attach them all to their respective namespaces.\n        var name = camelCase(m.name);\n        instruction[name] = ixItem;\n        transaction[name] = txItem;\n        rpc[name] = rpcItem;\n      });\n      return [instruction, transaction, rpc];\n    }(),\n        _ref2 = _slicedToArray(_ref, 3),\n        instruction = _ref2[0],\n        transaction = _ref2[1],\n        rpc = _ref2[2];\n\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the program ID owning the state.\n   */\n\n\n  _createClass(StateClient, [{\n    key: \"fetch\",\n\n    /**\n     * Returns the deserialized state account.\n     */\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var addr, accountInfo, state, expectedDiscriminator;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                addr = this.address();\n                _context.next = 3;\n                return this.provider.connection.getAccountInfo(addr);\n\n              case 3:\n                accountInfo = _context.sent;\n\n                if (!(accountInfo === null)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist \".concat(addr.toString()));\n\n              case 6:\n                // Assert the account discriminator is correct.\n                state = this._idl.state;\n\n                if (state) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error(\"State is not specified in IDL.\");\n\n              case 9:\n                _context.next = 11;\n                return stateDiscriminator(state.struct.name);\n\n              case 11:\n                expectedDiscriminator = _context.sent;\n\n                if (!expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error(\"Invalid account discriminator\");\n\n              case 14:\n                return _context.abrupt(\"return\", this.coder.state.decode(accountInfo.data));\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n    /**\n     * Returns the state address.\n     */\n\n  }, {\n    key: \"address\",\n    value: function address() {\n      return this._address;\n    }\n    /**\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n     * the state account cahnges.\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(commitment) {\n      var _this = this;\n\n      if (this._sub !== null) {\n        return this._sub.ee;\n      }\n\n      var ee = new EventEmitter();\n      var listener = this.provider.connection.onAccountChange(this.address(), function (acc) {\n        var account = _this.coder.state.decode(acc.data);\n\n        ee.emit(\"change\", account);\n      }, commitment);\n      this._sub = {\n        ee: ee,\n        listener: listener\n      };\n      return ee;\n    }\n    /**\n     * Unsubscribes to state changes.\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n\n      if (this._sub !== null) {\n        this.provider.connection.removeAccountChangeListener(this._sub.listener).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _this2._sub = null;\n\n                case 1:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }))).catch(console.error);\n      }\n    }\n  }, {\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n  }]);\n\n  return StateClient;\n}(); // Calculates the deterministic address of the program's \"state\" account.\n\nfunction programStateAddress(programId) {\n  var _findProgramAddressSy = findProgramAddressSync([], programId),\n      _findProgramAddressSy2 = _slicedToArray(_findProgramAddressSy, 1),\n      registrySigner = _findProgramAddressSy2[0];\n\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n} // Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\n\n\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    var _findProgramAddressSy3 = findProgramAddressSync([], programId),\n        _findProgramAddressSy4 = _slicedToArray(_findProgramAddressSy3, 1),\n        programSigner = _findProgramAddressSy4[0];\n\n    return [{\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":null,"metadata":{},"sourceType":"module"}