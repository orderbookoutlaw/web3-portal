{"ast":null,"code":"import _classCallCheck from \"/Users/user/Documents/GitHub/Buildspace/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/user/Documents/GitHub/Buildspace/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlError } from \"../error\";\nexport var IdlCoder = /*#__PURE__*/function () {\n  function IdlCoder() {\n    _classCallCheck(this, IdlCoder);\n  }\n\n  _createClass(IdlCoder, null, [{\n    key: \"fieldLayout\",\n    value: function fieldLayout(field, types) {\n      var fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n\n      switch (field.type) {\n        case \"bool\":\n          {\n            return borsh.bool(fieldName);\n          }\n\n        case \"u8\":\n          {\n            return borsh.u8(fieldName);\n          }\n\n        case \"i8\":\n          {\n            return borsh.i8(fieldName);\n          }\n\n        case \"u16\":\n          {\n            return borsh.u16(fieldName);\n          }\n\n        case \"i16\":\n          {\n            return borsh.i16(fieldName);\n          }\n\n        case \"u32\":\n          {\n            return borsh.u32(fieldName);\n          }\n\n        case \"i32\":\n          {\n            return borsh.i32(fieldName);\n          }\n\n        case \"u64\":\n          {\n            return borsh.u64(fieldName);\n          }\n\n        case \"i64\":\n          {\n            return borsh.i64(fieldName);\n          }\n\n        case \"u128\":\n          {\n            return borsh.u128(fieldName);\n          }\n\n        case \"i128\":\n          {\n            return borsh.i128(fieldName);\n          }\n\n        case \"bytes\":\n          {\n            return borsh.vecU8(fieldName);\n          }\n\n        case \"string\":\n          {\n            return borsh.str(fieldName);\n          }\n\n        case \"publicKey\":\n          {\n            return borsh.publicKey(fieldName);\n          }\n\n        default:\n          {\n            if (\"vec\" in field.type) {\n              return borsh.vec(IdlCoder.fieldLayout({\n                name: undefined,\n                // @ts-ignore\n                type: field.type.vec\n              }, types), fieldName);\n            } else if (\"option\" in field.type) {\n              return borsh.option(IdlCoder.fieldLayout({\n                name: undefined,\n                type: field.type.option\n              }, types), fieldName);\n            } else if (\"defined\" in field.type) {\n              var defined = field.type.defined; // User defined type.\n\n              if (types === undefined) {\n                throw new IdlError(\"User defined types not provided\");\n              }\n\n              var filtered = types.filter(function (t) {\n                return t.name === defined;\n              });\n\n              if (filtered.length !== 1) {\n                throw new IdlError(\"Type not found: \".concat(JSON.stringify(field)));\n              }\n\n              return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n            } else if (\"array\" in field.type) {\n              var arrayTy = field.type.array[0];\n              var arrayLen = field.type.array[1];\n              var innerLayout = IdlCoder.fieldLayout({\n                name: undefined,\n                type: arrayTy\n              }, types);\n              return borsh.array(innerLayout, arrayLen, fieldName);\n            } else {\n              throw new Error(\"Not yet implemented: \".concat(field));\n            }\n          }\n      }\n    }\n  }, {\n    key: \"typeDefLayout\",\n    value: function typeDefLayout(typeDef) {\n      var types = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var name = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (typeDef.type.kind === \"struct\") {\n        var fieldLayouts = typeDef.type.fields.map(function (field) {\n          var x = IdlCoder.fieldLayout(field, types);\n          return x;\n        });\n        return borsh.struct(fieldLayouts, name);\n      } else if (typeDef.type.kind === \"enum\") {\n        var variants = typeDef.type.variants.map(function (variant) {\n          var name = camelCase(variant.name);\n\n          if (variant.fields === undefined) {\n            return borsh.struct([], name);\n          } // @ts-ignore\n\n\n          var fieldLayouts = variant.fields.map(function (f) {\n            // @ts-ignore\n            if (f.name === undefined) {\n              throw new Error(\"Tuple enum variants not yet implemented.\");\n            } // @ts-ignore\n\n\n            return IdlCoder.fieldLayout(f, types);\n          });\n          return borsh.struct(fieldLayouts, name);\n        });\n\n        if (name !== undefined) {\n          // Buffer-layout lib requires the name to be null (on construction)\n          // when used as a field.\n          return borsh.rustEnum(variants).replicate(name);\n        }\n\n        return borsh.rustEnum(variants, name);\n      } else {\n        throw new Error(\"Unknown type kint: \".concat(typeDef));\n      }\n    }\n  }]);\n\n  return IdlCoder;\n}();","map":null,"metadata":{},"sourceType":"module"}