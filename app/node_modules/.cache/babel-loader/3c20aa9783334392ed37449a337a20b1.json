{"ast":null,"code":"import _objectSpread from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/user/Desktop/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\n\nexport var SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\n\nexport var SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\n\nexport var InstructionCoder = /*#__PURE__*/function () {\n  function InstructionCoder(idl) {\n    var _this = this;\n\n    _classCallCheck(this, InstructionCoder);\n\n    this.idl = idl;\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    var sighashLayouts = new Map();\n    idl.instructions.forEach(function (ix) {\n      var sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: _this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n\n    if (idl.state) {\n      idl.state.methods.map(function (ix) {\n        var sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: _this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n\n\n  _createClass(InstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n      var methodName = camelCase(ixName);\n      var layout = this.ixLayout.get(methodName);\n\n      if (!layout) {\n        throw new Error(\"Unknown method: \".concat(methodName));\n      }\n\n      var len = layout.encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n  }, {\n    key: \"decode\",\n\n    /**\n     * Dewcodes a program instruction.\n     */\n    value: function decode(ix) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n\n      if (typeof ix === \"string\") {\n        ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n      }\n\n      var sighash = bs58.encode(ix.slice(0, 8));\n      var data = ix.slice(8);\n      var decoder = this.sighashLayouts.get(sighash);\n\n      if (!decoder) {\n        return null;\n      }\n\n      return {\n        data: decoder.layout.decode(data),\n        name: decoder.name\n      };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(ix, accountMetas) {\n      return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          var _a, _b;\n\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          var _a, _b;\n\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      })); // @ts-ignore\n\n      return new Map(ixLayouts);\n    }\n  }]);\n\n  return InstructionCoder;\n}();\n\nvar InstructionFormatter = /*#__PURE__*/function () {\n  function InstructionFormatter() {\n    _classCallCheck(this, InstructionFormatter);\n  }\n\n  _createClass(InstructionFormatter, null, [{\n    key: \"format\",\n    value: function format(ix, accountMetas, idl) {\n      var idlIx = idl.instructions.filter(function (i) {\n        return ix.name === i.name;\n      })[0];\n\n      if (idlIx === undefined) {\n        console.error(\"Invalid instruction given\");\n        return null;\n      }\n\n      var args = idlIx.args.map(function (idlField) {\n        return {\n          name: idlField.name,\n          type: InstructionFormatter.formatIdlType(idlField.type),\n          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n        };\n      });\n      var flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n      var accounts = accountMetas.map(function (meta, idx) {\n        if (idx < flatIdlAccounts.length) {\n          return _objectSpread({\n            name: flatIdlAccounts[idx].name\n          }, meta);\n        } // \"Remaining accounts\" are unnamed in Anchor.\n        else {\n          return _objectSpread({\n            name: undefined\n          }, meta);\n        }\n      });\n      return {\n        args: args,\n        accounts: accounts\n      };\n    }\n  }, {\n    key: \"formatIdlType\",\n    value: function formatIdlType(idlType) {\n      if (typeof idlType === \"string\") {\n        return idlType;\n      }\n\n      if (\"vec\" in idlType) {\n        return \"Vec<\".concat(this.formatIdlType(idlType.vec), \">\");\n      }\n\n      if (\"option\" in idlType) {\n        return \"Option<\".concat(this.formatIdlType(idlType.option), \">\");\n      }\n\n      if (\"defined\" in idlType) {\n        return idlType.defined;\n      }\n\n      if (\"array\" in idlType) {\n        return \"Array<\".concat(idlType.array[0], \"; \").concat(idlType.array[1], \">\");\n      }\n\n      throw new Error(\"Unknown IDL type: \".concat(idlType));\n    }\n  }, {\n    key: \"formatIdlData\",\n    value: function formatIdlData(idlField, data, types) {\n      var _this2 = this;\n\n      if (typeof idlField.type === \"string\") {\n        return data.toString();\n      } // @ts-ignore\n\n\n      if (idlField.type.vec) {\n        // @ts-ignore\n        return \"[\" + data // @ts-ignore\n        .map(function (d) {\n          return _this2.formatIdlData( // @ts-ignore\n          {\n            name: \"\",\n            type: idlField.type.vec\n          }, d);\n        }).join(\", \") + \"]\";\n      } // @ts-ignore\n\n\n      if (idlField.type.option) {\n        // @ts-ignore\n        return data === null ? \"null\" : this.formatIdlData( // @ts-ignore\n        {\n          name: \"\",\n          type: idlField.type.option\n        }, data);\n      } // @ts-ignore\n\n\n      if (idlField.type.defined) {\n        if (types === undefined) {\n          throw new Error(\"User defined types not provided\");\n        } // @ts-ignore\n\n\n        var filtered = types.filter(function (t) {\n          return t.name === idlField.type.defined;\n        });\n\n        if (filtered.length !== 1) {\n          // @ts-ignore\n          throw new Error(\"Type not found: \".concat(idlField.type.defined));\n        }\n\n        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n      }\n\n      return \"unknown\";\n    }\n  }, {\n    key: \"formatIdlDataDefined\",\n    value: function formatIdlDataDefined(typeDef, data, types) {\n      if (typeDef.type.kind === \"struct\") {\n        var struct = typeDef.type;\n        var fields = Object.keys(data).map(function (k) {\n          var f = struct.fields.filter(function (f) {\n            return f.name === k;\n          })[0];\n\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n\n          return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n        }).join(\", \");\n        return \"{ \" + fields + \" }\";\n      } else {\n        if (typeDef.type.variants.length === 0) {\n          return \"{}\";\n        } // Struct enum.\n\n\n        if (typeDef.type.variants[0].name) {\n          var variants = typeDef.type.variants;\n          var variant = Object.keys(data)[0];\n          var enumType = data[variant];\n          var namedFields = Object.keys(enumType).map(function (f) {\n            var _a;\n\n            var fieldData = enumType[f];\n            var idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(function (v) {\n              return v.name === f;\n            })[0];\n\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n\n            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n          }).join(\", \");\n          var variantName = camelCase(variant, {\n            pascalCase: true\n          });\n\n          if (namedFields.length === 0) {\n            return variantName;\n          }\n\n          return \"\".concat(variantName, \" { \").concat(namedFields, \" }\");\n        } // Tuple enum.\n        else {\n          // TODO.\n          return \"Tuple formatting not yet implemented\";\n        }\n      }\n    }\n  }, {\n    key: \"flattenIdlAccounts\",\n    value: function flattenIdlAccounts(accounts, prefix) {\n      // @ts-ignore\n      return accounts.map(function (account) {\n        var accName = sentenceCase(account.name); // @ts-ignore\n\n        if (account.accounts) {\n          var newPrefix = prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName; // @ts-ignore\n\n          return InstructionFormatter.flattenIdlAccounts( // @ts-ignore\n          account.accounts, newPrefix);\n        } else {\n          return _objectSpread({}, account, {\n            name: prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName\n          });\n        }\n      }).flat();\n    }\n  }]);\n\n  return InstructionFormatter;\n}();\n\nfunction sentenceCase(field) {\n  var result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}","map":null,"metadata":{},"sourceType":"module"}